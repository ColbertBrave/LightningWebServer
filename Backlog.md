# 一些笔记，理解和备忘
## 理清思路
V1 上手直接开始写，一边写一边梳理思路，因为此时尚未能够将各部分知识完全融会贯通。写的过程中逐渐发现许多问题如果提前规划好是可以避免的。

## EPOLL的几种事件
+ EPOLLIN
+ EPOLLOUT
+ EPOLLET
+ EPOLLHUP
+ EPOLLRDHUP
+ EPOLLONESHOT

## 数据库连接池
### 什么是数据库连接池？
    池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化。通俗来说，池是资源的容器，本质上是对资源的复用。
    顾名思义，连接池中的资源为一组数据库连接，由程序动态地对池中的连接进行使用，释放。
    当系统开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配；
    当服务器处理完一个客户连接后,可以把相关的资源放回池中，无需执行系统调用释放资源。

### 数据库访问的一般流程是什么？
    当系统需要访问数据库时，先系统创建数据库连接，完成数据库操作，然后系统断开数据库连接。

### 为什么要创建连接池？
    从一般流程中可以看出，若系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。
    在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。

    池可以看做资源的容器，所以多种实现方法，比如数组、链表、队列等。这里，使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。
    项目中的数据库模块分为两部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能。具体的，工作线程从数据库连接池取得一个连接，
    访问数据库中的数据，访问完毕后将连接交还连接池。

## C++中的RAII机制
### 什么是RAII？
    RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。
    利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，
    最后在对象析构的时候，释放构造时获取的资源。

### 为什么要使用RAII？
    在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，
    它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，
    所以，我们在编程使用系统资源时，都必须遵循一个步骤：
    1 申请资源；
    2 使用资源；
    3 释放资源。
    第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。

### 如何使用RAII？
    当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是类对象时，
    这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。
    由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，
    对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，
    如此，就不用程序员显示的去调用释放资源的操作了。

## Event Loop
    对于一个服务器而言，随时可能有新的连接建立，或者有到期的定时事件需要处理，或者有IO事件需要处理，或者有计算任务，或者有突然发生的异常需要处理，我们将所有的需求都扔给Event Loop，然后由Event Loop管理分配任务给线程去执行任务。
    

## STL
    在容器vector中，其内存占用的空间是只增不减的，比如说首先分配了10,000个字节，然后erase掉后面9,999个，则虽然有效元素只有一个，
    但是内存占用仍为10,000个。所有内存空间在vector析构时回收。一般，我们都会通过vector中成员函数clear进行一些清除操作，但它清除的是所有的元素，
    使vector的大小减少至0，却不能减小vector占用的内存。要避免vector持有它不再需要的内存，这就需要一种方法来使得它从曾经的容量减少至它现在需要的容量，
    这样减少容量的方法被称为“收缩到合适（shrink to fit）。可以借助swap()来实现这一功能
    swap交换技巧实现内存释放思想：
        vector()使用vector的默认构造函数建立临时vector对象，再在该临时对象上调用swap成员，
        swap调用之后对象myvector占用的空间就等于一个默认构造的对象的大小，
        临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。

    并不是所有的STL容器的clear成员函数的行为都和vector一样。事实上，其他容器的clear成员函数都会释放其内存。比如另一个和vector类似的顺序容器deque。

## assert
    在网上看到很多关于使用assert的争论，摘录了其中一段（https://zhuanlan.zhihu.com/p/29385016）
    assert()的语义是什么呢？
    它是“断言”。“我断定它是这样的”，就用断言。“Kenneth是个好人”，这是断言，“a必然等于4”，这也是断言。断言在解决问题上是无用的东西，因为它不进入决策链，比如“巧克力很好吃”，这是断言，不产生决策，“但我现在吃饭”，这才是决策，对程序来说，大部分时候我们关心这个，而不是巧克力好不好吃。但断言在交流上是有用的东西，它可以让我们很快知道双方是否有分歧，从而判断是否进入细致逻辑。比如这个论文：https://pdos.csail.mit.edu/6.828/2017/readings/linux-lock.pdf，它断言成功获取锁等待时间是c*k/2，如果我的硬件构架和这个断言不一致，这个论文的整个结论就对我不可靠，我就可以不看下去。从这里就可以看出，断言的主要作用是“声称什么东西在作者的考虑范围内，什么东西不在作者的考虑范围内”。这就是为什么我要用断言来说明怎么写“专业的程序”，“专业的程序”要求“算无遗着”，但严格来说，“算无遗着”是不可能的，太阳黑子变化，可以导致你某个变量的一个bit发生跳变，你每次访问这个变量的时候都去校验一下吗？所以，断言的作用在于在一个“代码结构”之内“算无遗着”，比如我有如下代码结构：
    '''C++
    int a[SZ_T];
    for(i=0; i<data_num; i++)
        a[i] = 1/a[i];
    '''
    这个代码目之所及，有很多不可靠的地方，如果我们加上断言，它就可靠了：
    '''
    int a[SZ];
    assert(data_num<SZ);
    for(i=0; i<data_num; i++) 
    {
        assert(a[i]!=0);
        a[i] = 1/a[i];
    }
    '''
    有人会争辩说，这个地方应该用实际的代码去检查。如果真的需要，这个我不反对。但出于性能的考虑，你不可能到处都进行多余的检查，在你做完所有那些检查后，我们回到这个问题，你的每个“代码结构”是否无懈可击？——很可能，再加上断言之前，不是。那么，什么地方应该加断言，这个就不用我说了。理解断言，核心问题不在于断言的用途本身，而是“在语义上算无遗着”这个理念。接着我们要谈断言带来的第二个编程理念：一切皆在预期之内。做可靠性的人都会很关心两个概念，所谓的Failure和Error（不是每个语言空间都用同一个词表达我这里要表达的意思，但概念都是存在的）。Failure是系统的输出不符合预期，Error是导致输出不符合预期的那个设计。用户在乎前者，程序员在乎后者。因为多个Error综合，可以导致Failure不成为Failure，但这个不是必然。用户关心他当时使用的Snapshot，程序关心的所有有效时间和空间上的SnapShot。所以我们需要程序在可能的时候，永远都在计算的范围之内。这是断言的第二个作用，大量多余的，在一个个独立的代码结构范围内保证计算条件的断言，就可以有效控制，整个执行流一直在预期的计算范围内，程序出问题的可能性就比不控制这个要小得多。这个策略可以引申，我在写高性能程序的时候，不但大量使用断言，还大量使用统计，比如一个网卡，发送接收的数据量，包数，不同长度包的分布，不同分段的分布，各种不同类型的错误流程进入的次数。你要掌控一个系统，就要能保证它的全部运作在你的“设想之内”，这样你所有的升级，优化，质量控制，才会有根本。

