# 一些笔记，理解和备忘
## 理清思路
V1 上手直接开始写，一边写一边梳理思路，因为此时尚未能够将各部分知识完全融会贯通。写的过程中逐渐发现许多问题如果提前规划好是可以避免的。

## EPOLL的几种事件
+ EPOLLIN
+ EPOLLOUT
+ EPOLLET
+ EPOLLHUP
+ EPOLLRDHUP
+ EPOLLONESHOT

## 数据库连接池
### 什么是数据库连接池？
    池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化。通俗来说，池是资源的容器，本质上是对资源的复用。
    顾名思义，连接池中的资源为一组数据库连接，由程序动态地对池中的连接进行使用，释放。
    当系统开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配；
    当服务器处理完一个客户连接后,可以把相关的资源放回池中，无需执行系统调用释放资源。

### 数据库访问的一般流程是什么？
    当系统需要访问数据库时，先系统创建数据库连接，完成数据库操作，然后系统断开数据库连接。

### 为什么要创建连接池？
    从一般流程中可以看出，若系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。
    在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。

    池可以看做资源的容器，所以多种实现方法，比如数组、链表、队列等。这里，使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。
    项目中的数据库模块分为两部分，其一是数据库连接池的定义，其二是利用连接池完成登录和注册的校验功能。具体的，工作线程从数据库连接池取得一个连接，
    访问数据库中的数据，访问完毕后将连接交还连接池。

## C++中的RAII机制
### 什么是RAII？
    RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。
    利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，
    最后在对象析构的时候，释放构造时获取的资源。

### 为什么要使用RAII？
    在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，
    它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，
    所以，我们在编程使用系统资源时，都必须遵循一个步骤：
    1 申请资源；
    2 使用资源；
    3 释放资源。
    第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。

### 如何使用RAII？
    当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就别销毁了；当这个变量是类对象时，
    这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。这个也太好了，RAII就是这样去完成的。
    由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，
    对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，
    如此，就不用程序员显示的去调用释放资源的操作了。

## Event Loop
    对于一个服务器而言，随时可能有新的连接建立，或者有到期的定时事件需要处理，或者有IO事件需要处理，或者有计算任务，或者有突然发生的异常需要处理，我们将所有的需求都扔给Event Loop，然后由Event Loop管理分配任务给线程去执行任务。
    

## STL
    在容器vector中，其内存占用的空间是只增不减的，比如说首先分配了10,000个字节，然后erase掉后面9,999个，则虽然有效元素只有一个，
    但是内存占用仍为10,000个。所有内存空间在vector析构时回收。一般，我们都会通过vector中成员函数clear进行一些清除操作，但它清除的是所有的元素，
    使vector的大小减少至0，却不能减小vector占用的内存。要避免vector持有它不再需要的内存，这就需要一种方法来使得它从曾经的容量减少至它现在需要的容量，
    这样减少容量的方法被称为“收缩到合适（shrink to fit）。可以借助swap()来实现这一功能
    swap交换技巧实现内存释放思想：
        vector()使用vector的默认构造函数建立临时vector对象，再在该临时对象上调用swap成员，
        swap调用之后对象myvector占用的空间就等于一个默认构造的对象的大小，
        临时对象就具有原来对象v的大小，而该临时对象随即就会被析构，从而其占用的空间也被释放。

    并不是所有的STL容器的clear成员函数的行为都和vector一样。事实上，其他容器的clear成员函数都会释放其内存。比如另一个和vector类似的顺序容器deque。


