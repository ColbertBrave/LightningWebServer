### 模板链接问题
问题阐述：
在LogBuffer.h中定义了一个类，在LogBuffer.cpp中定义了相应了成员函数，链接时出现问题，报错如下
```
g++ main.cpp LogBuffer.cpp -o test
/usr/bin/ld: /tmp/ccdWdFGZ.o: in function `main':
main.cpp:(.text+0x9c): undefined reference to `LogBuffer<512u>::Append(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, unsigned long)'
/usr/bin/ld: main.cpp:(.text+0xba): undefined reference to `LogBuffer<512u>::Available()'
/usr/bin/ld: main.cpp:(.text+0xed): undefined reference to `LogBuffer<512u>::Occupied()'
/usr/bin/ld: main.cpp:(.text+0x120): undefined reference to `LogBuffer<512u>::Reset()'
/usr/bin/ld: main.cpp:(.text+0x12f): undefined reference to `LogBuffer<512u>::Available()'
/usr/bin/ld: main.cpp:(.text+0x162): undefined reference to `LogBuffer<512u>::Occupied()'
collect2: error: ld returned 1 exit status
make: *** [Makefile:4: test] Error 1
```
代码如下：
在**LogBuffer.h**中定义了class LogBuffer
```
template <unsigned int SIZE>
class LogBuffer
{
    // ...

public:
    LogBuffer()
    {
        this->BufferSize = SIZE;
        this->Buffer.fill('\0');
        this->Cur = 0;
    }
    ~LogBuffer() {}

    bool Append(std::string log, size_t len);
    void Reset();
    size_t Occupied();
    size_t Available();
};
```

在**LogBuffer.cpp**中定义了类成员方法
```
template <unsigned int SIZE>
size_t LogBuffer::Available()
{
    //...
}

template <unsigned int SIZE>
size_t LogBuffer::Occupied()
{
    //...
}

template <unsigned int SIZE>
void LogBuffer<SIZE>::Reset()
{
    //...
}
```

**main.cpp**
```
LogBuffer<512> log;
string msg = "Failed to create error!";
log.Append(msg, sizeof(msg));
cout << log.Available() << endl;
cout << log.Occupied() << endl;

log.Reset();
cout << log.Available() << endl;
cout << log.Occupied() << endl;
```

在stackoverflow上找到了解答
https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file
https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl
https://stackoverflow.com/questions/44774036/why-use-a-tpp-file-when-implementing-templated-functions-and-classes-defined-i/44774074

解决方法一：模板全部在头文件中实现
解决方法二：extern template特性
解决方法三：在.h文件定义，在.tpp文件中实现，如下：
```
template <unsigned int SIZE>
class LogBuffer
{
    // ...

public:
    LogBuffer()
    {
        this->BufferSize = SIZE;
        this->Buffer.fill('\0');
        this->Cur = 0;
    }
    ~LogBuffer() {}

    bool Append(std::string log, size_t len);
    void Reset();
    size_t Occupied();
    size_t Available();
};

#include "LogBuffer.tpp"
```

在**LogBuffer.tpp**中定义了类成员方法
```
template <unsigned int SIZE>
size_t LogBuffer::Available()
{
    //...
}

template <unsigned int SIZE>
size_t LogBuffer::Occupied()
{
    //...
}

template <unsigned int SIZE>
void LogBuffer<SIZE>::Reset()
{
    //...
}
```
运行OK.

### 无法将函数定义与现有的声明匹配
报错：
```
"LogBuffer::Occupied()":无法将函数定义与现有的声明匹配
...
```

在LogBuffer.h中定义了class LogBuffer
```
template <unsigned int SIZE>
class LogBuffer
{
    // ...

public:
    LogBuffer()
    {
        this->BufferSize = SIZE;
        this->Buffer.fill('\0');
        this->Cur = 0;
    }
    ~LogBuffer() {}

    bool Append(std::string log, size_t len);
    void Reset();
    size_t Occupied();
    size_t Available();
};
```

在LogBuffer.cpp中定义了类成员方法
```
template <unsigned int SIZE>
size_t LogBuffer::Available()
{
    //...
}

template <unsigned int SIZE>
size_t LogBuffer::Occupied()
{
    //...
}

template <unsigned int SIZE>
void LogBuffer<SIZE>::Reset()
{
    //...
}
```

检查了好久，终于发现了错误函数名后少些了<>，修改后
```
template <unsigned int SIZE>
size_t LogBuffer<SIZE>::Available()
{
    return this->BufferSize - this->Occupied();
}

template <unsigned int SIZE>
size_t LogBuffer<SIZE>::Occupied()
{
    return static_cast<size_t>(this->Cur);
}

template <unsigned int SIZE>
void LogBuffer<SIZE>::Reset()
{
    this->Buffer.fill('\0');
    this->Cur = 0;
}
```

运行OK了。

