在类的构造函数里启动了一个线程，线程函数是类的一个成员函数，报错如下：
```C++
Logging.cpp:26:45: error: invalid use of non-static member function ‘void Logging::LogThreadFunc()’
   26 |     if (pthread_create(&LogThread_ID, NULL, LogThreadFunc, NULL) != 0)
      |                                             ^~~~~~~~~~~~~
In file included from Logging.cpp:1:
Logging.h:28:10: note: declared here
   28 |     void LogThreadFunc();
      |          ^~~~~~~~~~~~~
make: *** [Makefile:8: Logging.o] Error 1
```
经过查阅后: pthread_create的线程函数必须是一个静态成员函数
这里又有一个坑，静态成员函数在.h文件里声明时需要加上static关键字，在.cpp文件中定义时无需再加上static关键字
原因如下：
```
static的用法有好几种，在类中成员函数的声明使用static关键字则是规定说该成员函数为该类所有实例所共享
也就是所谓的"one-per-class"，而在.cpp文件中使用static关键字的作用也是说该函数或变量仅仅只有该文件可以访问，
这就与第一个用法冲突了。不过在这种情况时，定义static的类成员变量不需要再使用static关键字了，
或者直接在.h文件中声明+定义
```
最终通过如下方法实现：
```C++
// Logging.h
static void* run(void* args);
```
```C++
// Logging.cpp
void* run(void* args)
{
    Loggging LOG* = static_cast<Logging*>(args);
    //...
    LOG->LogThreadFunc();
}

//...
    pthread_create(&LogThread_ID, NULL, run, this)
```
最终运行OK了