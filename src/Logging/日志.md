### 步骤
- gcc -g -o test test.cc
  
### TODO
+ 正常退出时应当先保存完所有日志再退出: 不能自动调用析构退出，应当增加shutdown函数将所有日志完全保存后退出
+ 考虑在每个Buffer上加锁解锁 DONE
+ 考虑在Buffer数量不够时扩容 
+ 写入日志增加线程ID DONE TODO 应当加写入线程的tid，而不是日志线程的tid
+ UTC时间优化 
+ 修改值传递 
+ 为什么写入实际数目和预设数目不符？


### 记录
+ 调整buffer数量和大小：从4*4KB调整为12*1024KB，写入速度从1.2万次/秒增加到了15次/秒
+ 将读取保存时从整个链表加锁解锁变为在单个buffer上加锁解锁，写入速度从15万次增加了50万次/秒

+ NOTE 智能指针尽量使用make_shared优化
std::shared_ptr<Widget> spw(new Widget); 需要分配两次内存。每个std::shared_ptr都指向一个控制块，控制块包含被指向对象的引用计数以及其他东西。这个控制块的内存是在std::shared_ptr的构造函数中分配的。因此直接使用new，需要一块内存分配给Widget，还要一块内存分配给控制块

autospw = std::make_shared<Widget>(); 一次分配就足够了。这是因为std::make_shared申请一个单独的内存块来同时存放Widget对象和控制块。这个优化减少了程序的静态大小，因为代码只包含一次内存分配的调用，并且这会加快代码的执行速度，因为内存只分配了一次。另外，使用std::make_shared消除了一些控制块需要记录的信息，这样潜在地减少了程序的总内存占用。

  