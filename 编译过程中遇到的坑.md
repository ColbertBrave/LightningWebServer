### Segmentation fault
    遇到这个错误是在使用pthread_create()时，使用g++命令时要加上-lpthread，报错"Segmentation fault"
    引起原因通常是访问了不应当访问的地址
    错误的原代码大概如下:

    #include <pthread.h>
    void* worker(void* arg)
    {
        //...
    }

    int main()
    {
        pthread_t *ID = 0;
        if (pthread_create(ID, NULL, worker, NULL) == 0)
        {
            //...
        }
        return 0;
    }

    错误原因: 
    pthread_t *ID = 0 这里定义了一个空指针(和使用NULL是一样的)，并没有指向任何对象。
    调用pthread_create时创建的线程标识符存放至ID(此时地址ID为0，在系统里一般 0 地址均为系统关键地址)，此时访问了不允许访问的地址，导致报错。
    代码修改如下:

    pthread_t ID;   // 系统分配一块内存
    if (pthread_create(&ID, NULL, worker, NULL) == 0)
    {
        //...
    }

    或者：
    pthread_t *ID = new pthread_t;   
    if (pthread_create(ID, NULL, worker, NULL) == 0)
    {
        //...
    }

    delete ID;
    return 0

    修改完之后方向虽然不报错了，但是结果与预期不符，后来发现忘了阻塞线程了😥，再次修改后
    pthread_t ID;   
    if (pthread_create(&ID, NULL, worker, NULL) == 0)
    {
        //...
    }

    pthread_join(ID, NULL);
    return 0;

    结果终于OK了。

